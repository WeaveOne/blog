# 深入理解java虚拟机

## java内存区域

### 对象头

1. 存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。官方称之为`Mark Word`

   |               存储内容               | 标志位 |        状态        |
   | :----------------------------------: | :----: | :----------------: |
   |       对象哈希码、对象分代年龄       |   01   |       未锁定       |
   |           指向锁记录的指针           |   00   |     轻量级锁定     |
   |          指向重量级锁得指针          |   10   | 膨胀（重量级锁定） |
   |          空，不需要记录信息          |   11   |       GC标志       |
   | 偏向线程ID、偏向时间戳、对象分代年龄 |   01   |       可偏向       |

2. 对象指向它的类元数据的指针，通过这个指针来确定这个对象是哪个类的实例。如果是数组还必须记录数组长度

3. 自动内存管理要求对象起始地址必须是8字节的倍数

### OutOfMemoryError异常

1. 几个参数：

   | 参数                            | 描述               |
   | ------------------------------- | ------------------ |
   | -XX:+PrintGCDetails             | 打印详细GC收集信息 |
   | -XmnN                           | 设置新生代固定大小 |
   | -XX:+HeapDumpOnOutOfMemoryError | 开启内存堆转储     |

2. 工具：`Eclipse Memory Amalyzer`

3. 内存泄漏处理：通过工具查看泄漏对象到GC Roots的引用链，查看如果导致无法自动回收

4. 不存在泄漏：应该检查堆参数是否可以调大，从代码上查看是否存在某些对象生命周期过长、持有时间过长，尝试减少程序运行期的内存消耗

### 虚拟机栈和本地方法一处

1. -XssN 设置栈空间大小
2. 两种异常
   1. 如果线程请求的栈深度大于虚拟机所允许的最大深度，抛出`StackOverflowError`
   2. 如果虚拟机在扩展栈时无法申请到足够的内存空间，抛出`OutOfMemoryError`
3. 栈容量越大，可分配的线程数量就越少
4. 可以通过减少最大堆和减少栈容量换取更多的线程。也可通过减少内存在解决

### 方法区和运行时常量池溢出

```java
    public static void main(String[] args) {
        // java7 后使用intern() 在字符串首次使用时，返回的引用与创建的实例是同一个
        // 使用StringBuilder 不会在常量池中保存字符串
        // 使用new String() 会在常量池保存字符串
        String str = new String("计算机");
        // 因为在常量池中已经有对象,所以intern()返回的就是常量池的对象
        System.out.println(str.intern() == str);
        String str1 = new StringBuilder("计算机").append("科学").toString();
        System.out.println(str1.intern() == str1);
        String str2 = new StringBuilder("ja").append("va").toString();
        System.out.println(str2.intern() == str2);
    }
```

1. 使用常量池造成内存溢出
2. 使用CGLIB动态生成大量的类，造成方法区内存溢出

## 垃圾收集器与内存分配策略

### 引用计数算法

给对象中添加一个引用计数器，每当一个地发引用计数器值就加1,当引用失效就-1.任何时刻计数器为0的对象就是不可能再被使用的

缺点：无法解决对象间相互循环引用的问题

### 可达性分析算法

通过一系列称为“GC Roots”的对象作为起始点，从这些绝点开始乡下搜索，搜索所走过的路径称为引用链，当一个对象到GCRoots没有任何的引用链相连时，则证明此对象时不可达的，所以他们将被判定为可回收对象

![1564366470559](C:\Users\user\Desktop\images\1564366145893.png)

可作为GC Roots的对象包括下面几种

1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI（Native方法）引用的对象

### 垃圾收集算法

1. 标记-清除算法
2. 复制算法 E S0 -> S1   ;   E S1 -> S0
3. 标记-整理算法
4. 分代收集 新生代就用复制算法，老年代就用：标记-清理 或者 标记-整理

### HotSpot的算法实现

#### 枚举根节点

1. 可达性分析需要整个分析期间整个执行系统看起来就像被冻结在某个时间点，不可以出现分析过程中引用关系还在不断变化，该店不满足的话分析结果准确性就无法得到保证。
2. OopMap会在存放特定位置的对象





## 小记

1. `吞吐量 = 运行用户代码时间/ (运行用户代码时间 + 垃圾收集时间)`

## 虚拟机性能监控与故障处理工具

### Sun JDK监控和故障处理工具

| 名称   | 主要作用                                                     |
| ------ | ------------------------------------------------------------ |
| jps    | 显示指定系统内所有的虚拟机进程                               |
| jstat  | 用语收集虚拟机各方面的运行数据                               |
| jinfo  | 显示虚拟机配置信息                                           |
| jmap   | 生成虚拟机的内存转储快照                                     |
| jhat   | 用语分析hepdump文件，建立一个http服务器，让用户可以在浏览器查看分析结果 |
| jstack | 显示虚拟机的线程快照                                         |

